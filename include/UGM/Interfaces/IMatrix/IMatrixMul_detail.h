#pragma once

namespace Ubpa {
	namespace detail {
		template<typename M, size_t N>
		struct inverse;

		template<typename M>
		struct inverse<M, 3> {
            using F = typename M::F;
			static const M run(const M& m) noexcept {
				F determinant = m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
					+ m[1][0] * (m[2][1] * m[0][2] - m[0][1] * m[2][2])
					+ m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]);

				assert(determinant != static_cast<F>(0));

				F inverseDeterminant = static_cast<F>(1) / determinant;

				M rst{};

				rst[0][0] = (m[1][1] * m[2][2] - m[2][1] * m[1][2]) * inverseDeterminant;
				rst[1][0] = (m[2][0] * m[1][2] - m[1][0] * m[2][2]) * inverseDeterminant;
				rst[2][0] = (m[1][0] * m[2][1] - m[2][0] * m[1][1]) * inverseDeterminant;
				rst[0][1] = (m[2][1] * m[0][2] - m[0][1] * m[2][2]) * inverseDeterminant;
				rst[1][1] = (m[0][0] * m[2][2] - m[2][0] * m[0][2]) * inverseDeterminant;
				rst[2][1] = (m[2][0] * m[0][1] - m[0][0] * m[2][1]) * inverseDeterminant;
				rst[0][2] = (m[0][1] * m[1][2] - m[1][1] * m[0][2]) * inverseDeterminant;
				rst[1][2] = (m[1][0] * m[0][2] - m[0][0] * m[1][2]) * inverseDeterminant;
				rst[2][2] = (m[0][0] * m[1][1] - m[1][0] * m[0][1]) * inverseDeterminant;

				return rst;
			}
		};

		template<typename M>
		struct inverse<M, 4> {
            using F = typename M::F;
            // https://stackoverflow.com/questions/1148309/inverting-a-4x4-matrix
            static const M run(const M& m) noexcept {
                M rst{};

                rst[0][0] = m[1][1] * m[2][2] * m[3][3] -
                    m[1][1] * m[2][3] * m[3][2] -
                    m[2][1] * m[1][2] * m[3][3] +
                    m[2][1] * m[1][3] * m[3][2] +
                    m[3][1] * m[1][2] * m[2][3] -
                    m[3][1] * m[1][3] * m[2][2];

                rst[1][0] = -m[1][0] * m[2][2] * m[3][3] +
                    m[1][0] * m[2][3] * m[3][2] +
                    m[2][0] * m[1][2] * m[3][3] -
                    m[2][0] * m[1][3] * m[3][2] -
                    m[3][0] * m[1][2] * m[2][3] +
                    m[3][0] * m[1][3] * m[2][2];

                rst[2][0] = m[1][0] * m[2][1] * m[3][3] -
                    m[1][0] * m[2][3] * m[3][1] -
                    m[2][0] * m[1][1] * m[3][3] +
                    m[2][0] * m[1][3] * m[3][1] +
                    m[3][0] * m[1][1] * m[2][3] -
                    m[3][0] * m[1][3] * m[2][1];

                rst[3][0] = -m[1][0] * m[2][1] * m[3][2] +
                    m[1][0] * m[2][2] * m[3][1] +
                    m[2][0] * m[1][1] * m[3][2] -
                    m[2][0] * m[1][2] * m[3][1] -
                    m[3][0] * m[1][1] * m[2][2] +
                    m[3][0] * m[1][2] * m[2][1];

                rst[0][1] = -m[0][1] * m[2][2] * m[3][3] +
                    m[0][1] * m[2][3] * m[3][2] +
                    m[2][1] * m[0][2] * m[3][3] -
                    m[2][1] * m[0][3] * m[3][2] -
                    m[3][1] * m[0][2] * m[2][3] +
                    m[3][1] * m[0][3] * m[2][2];

                rst[1][1] = m[0][0] * m[2][2] * m[3][3] -
                    m[0][0] * m[2][3] * m[3][2] -
                    m[2][0] * m[0][2] * m[3][3] +
                    m[2][0] * m[0][3] * m[3][2] +
                    m[3][0] * m[0][2] * m[2][3] -
                    m[3][0] * m[0][3] * m[2][2];

                rst[2][1] = -m[0][0] * m[2][1] * m[3][3] +
                    m[0][0] * m[2][3] * m[3][1] +
                    m[2][0] * m[0][1] * m[3][3] -
                    m[2][0] * m[0][3] * m[3][1] -
                    m[3][0] * m[0][1] * m[2][3] +
                    m[3][0] * m[0][3] * m[2][1];

                rst[3][1] = m[0][0] * m[2][1] * m[3][2] -
                    m[0][0] * m[2][2] * m[3][1] -
                    m[2][0] * m[0][1] * m[3][2] +
                    m[2][0] * m[0][2] * m[3][1] +
                    m[3][0] * m[0][1] * m[2][2] -
                    m[3][0] * m[0][2] * m[2][1];

                rst[0][2] = m[0][1] * m[1][2] * m[3][3] -
                    m[0][1] * m[1][3] * m[3][2] -
                    m[1][1] * m[0][2] * m[3][3] +
                    m[1][1] * m[0][3] * m[3][2] +
                    m[3][1] * m[0][2] * m[1][3] -
                    m[3][1] * m[0][3] * m[1][2];

                rst[1][2] = -m[0][0] * m[1][2] * m[3][3] +
                    m[0][0] * m[1][3] * m[3][2] +
                    m[1][0] * m[0][2] * m[3][3] -
                    m[1][0] * m[0][3] * m[3][2] -
                    m[3][0] * m[0][2] * m[1][3] +
                    m[3][0] * m[0][3] * m[1][2];

                rst[2][2] = m[0][0] * m[1][1] * m[3][3] -
                    m[0][0] * m[1][3] * m[3][1] -
                    m[1][0] * m[0][1] * m[3][3] +
                    m[1][0] * m[0][3] * m[3][1] +
                    m[3][0] * m[0][1] * m[1][3] -
                    m[3][0] * m[0][3] * m[1][1];

                rst[3][2] = -m[0][0] * m[1][1] * m[3][2] +
                    m[0][0] * m[1][2] * m[3][1] +
                    m[1][0] * m[0][1] * m[3][2] -
                    m[1][0] * m[0][2] * m[3][1] -
                    m[3][0] * m[0][1] * m[1][2] +
                    m[3][0] * m[0][2] * m[1][1];

                rst[0][3] = -m[0][1] * m[1][2] * m[2][3] +
                    m[0][1] * m[1][3] * m[2][2] +
                    m[1][1] * m[0][2] * m[2][3] -
                    m[1][1] * m[0][3] * m[2][2] -
                    m[2][1] * m[0][2] * m[1][3] +
                    m[2][1] * m[0][3] * m[1][2];

                rst[1][3] = m[0][0] * m[1][2] * m[2][3] -
                    m[0][0] * m[1][3] * m[2][2] -
                    m[1][0] * m[0][2] * m[2][3] +
                    m[1][0] * m[0][3] * m[2][2] +
                    m[2][0] * m[0][2] * m[1][3] -
                    m[2][0] * m[0][3] * m[1][2];

                rst[2][3] = -m[0][0] * m[1][1] * m[2][3] +
                    m[0][0] * m[1][3] * m[2][1] +
                    m[1][0] * m[0][1] * m[2][3] -
                    m[1][0] * m[0][3] * m[2][1] -
                    m[2][0] * m[0][1] * m[1][3] +
                    m[2][0] * m[0][3] * m[1][1];

                rst[3][3] = m[0][0] * m[1][1] * m[2][2] -
                    m[0][0] * m[1][2] * m[2][1] -
                    m[1][0] * m[0][1] * m[2][2] +
                    m[1][0] * m[0][2] * m[2][1] +
                    m[2][0] * m[0][1] * m[1][2] -
                    m[2][0] * m[0][2] * m[1][1];

                F det = m[0][0] * rst[0][0] + m[0][1] * rst[1][0] + m[0][2] * rst[2][0] + m[0][3] * rst[3][0];

                assert(det != static_cast<F>(0));

                F invDet = static_cast<F>(1) / det;

                rst *= invDet;

                return rst;
            }
		};

		template<typename M>
		const M run_inverse(const M& m) noexcept {
			return inverse<M, M::N>::run(m);
		}
	}
}